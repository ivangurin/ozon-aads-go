# Хеш-таблица с закрытой адресацией

## Условие задачи

Даша пишет программу, анализирующую сформированные особым образом файлы, и для этого ей понадобилось реализовать хеш-таблицу со следующими свойствами:

- Строкой называется последовательность ASCII-символов $x$ в диапазоне 33 <= x <=> 126.
- Ключи и значения хеш-таблицы — $строки$.
- Хеш $строки$, состоящей из символов $c_0, ..., c_m$ считается по формуле:
  $hash(h_0, ..., h_m) = h_0 * 33^{m} + h_1 * 33^{m-1} + ... + h_{m-1} * 33 + h_m =sum{i=1}^{m} h_i * 33^m-i$, где $h_i = c_i - 33$ — хеш символа $c_i$ строки.

В рекурсивной форме:

$
        hash() = 0; hash(h_0, ..., h_m) = hash(h_0, ... h_{m-1}) * 33 + h_m
$

- Начальная ёмкость хеш-таблицы — $4$.
- Коэффициент заполнения хеш-таблицы — $frac{3}{4} = 0.75$.
- Доступны операции:
- $put(key, value)$ — вставка значения value по ключу key(или замена значения по ключу, если этот ключ уже присутствует).
- $get(key) -> value$ — получение значения $value$ по ключу $key$.
- $print()$ — вывод структуры хеш-таблицы.
- Увеличение ёмкости (расширение) происходит при достижении коэффициента заполнения, то есть сразу после вставки, в результате которой количество уникальных ключей в таблице стало не менее $0.75$ её ёмкости.

- Ёмкость хеш-таблицы при расширении увеличивается в $2$ раза.
- Используется закрытая адресация на основе односвязных списков.
- Новые элементы в общем бакете добавляются в конец списка.
- При расширении, хеш-таблицы, элементы списка в бакете добавляются в расширенную хеш-таблицу в порядке обхода, в результате чего последовательность этих элементов в бакете разворачивается.
  Например, если до расширения был бакет
  $$A1 -> A2 -> B1 -> A3 -> B2$$
  и произошло расширение, в результате которого вершины $A*$ и $B*$ отправились в различные бакеты,
  то эти бакеты будут иметь вид:
  $$A3 -> A2 -> A1$$
  и
  $$B2 -> B1$$
  Что позволяет иметь более простую операцию.

Помоги Даше реализовать хеш-таблицу.

## Входные данные

В первой строке вводится натуральное число $N$ — число операций, которые требуется выполнить.
$N$ не превышает $2^{31}$.

Последующие $N$ строчек описывают одну из команд:

- $put KEY VALUE$: записывает (или перезаписывает) пару ключ-значение,
  где $KEY$ — ключ, а $VALUE$ — значение.
- $get KEY$: получает значение по ключу, где $KEY$ — ключ.
- $print$: выводит структуру хеш-таблицы.

## Выходные данные

Для операции $put$ ничего не выводится.

Для операции $get$, обнаружившей значение $VALUE$
выводится значение после символа <<плюс>> без пробелов ($+VALUE$) и перенос строки,
если значение не обнаружено, то выводится символ <<минус>> ($-$) и перенос строки.

Для операции $print$ выводится пара из размера $SIZE$ и ёмкости $CAPACITY$ через пробел ($SIZE CAPACITY$) и перенос строки.
Последующие $CAPACITY$ строчек содержат последовательность пар ключ-значение (с последующим переносом строки), для данного бакета,
где каждая пара записана как \t $KEY VALUE$, то есть подряд идущие:

- символ табуляции (\t, $9$ в ASCII);
- ключ $KEY$;
- символ пробела ($32$ в ASCII);
- значение $VALUE$.

Например, если бакет представляет из себя цепочку
$(A1, 07) -> (A2, 09)  -> (A3, 20)$
то для него должно быть выведено
$A1 07  A2 09   A3 20$

## Пример теста 1

### Входные данные

```
7
put 1 foo
put 3 bar
put 1 baz
get 3
print
get 2
get 1

```

### Выходные данные

```
+bar
2 4
	1 baz

	3 bar

-
+baz

```

## Пример теста 2

### Входные данные

```
24
put 1 foo
put 4 bar
print
put 2 baz
print
put 3 quux
put 1 new
put 5 corge
print
put 8 extra
put A collide
put B collide
put A replace
print
get 5
get 4
get 9
get 3
get 2
get 1
get A
get B
get 8
get n

```

### Выходные данные

```
2 4
	1 foo


	4 bar
3 8
	1 foo
	2 baz

	4 bar




5 8
	1 new
	2 baz
	3 quux
	4 bar
	5 corge



8 16
	1 new	A replace
	2 baz	B collide
	3 quux
	4 bar
	5 corge


	8 extra








+corge
+bar
-
+quux
+baz
+new
+replace
+collide
+extra
-

```
